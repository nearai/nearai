import logging
from typing import Optional

from fastapi import APIRouter, Body, Depends, HTTPException
from fastapi.responses import StreamingResponse
from sqlalchemy import select

from hub.api.v1.auth import AuthToken, revokable_auth
from hub.api.v1.models import (
    Delta,
    Message,
    Run,
    Thread,
    get_session,
)
from hub.api.v1.thread_routes import _check_thread_permissions, run_queues  # Import run_queues from thread_routes

streaming_router = APIRouter(prefix="/v1", tags=["streaming"])
logger = logging.getLogger(__name__)


@streaming_router.post("/threads/{thread_id}/messages/{message_id}/deltas")
async def create_delta(
    thread_id: str,
    message_id: str,
    run_id: str,
    delta: Delta = Body(...),
    auth: AuthToken = Depends(revokable_auth),
) -> None:
    """Create a streaming delta. Allows a runner to stream updates that are not generated by hub completions.

    Args:
        thread_id (str): The ID of the thread.
        message_id (str): The ID of the message to attach the delta to.
        run_id (Optional[str]): The ID of the run (if applicable).
        delta (Delta): The delta object containing content or metadata updates.
        auth (AuthToken): Authentication token for access control.

    Raises:
        HTTPException: If the message or thread isn't found or access is denied.

    """
    with get_session() as session:
        # Fetch the message
        message = session.get(Message, message_id)
        if not message:
            logger.error(f"Message not found: {message_id}")
            raise HTTPException(status_code=404, detail="Message not found")

        _check_thread_permissions(auth, session, thread_id)

        if message.thread_id != thread_id:
            logger.error(f"Message {message_id} does not belong to thread {thread_id}")
            raise HTTPException(status_code=400, detail="Message-thread mismatch")

        if run_id:
            run = session.get(Run, run_id)
            if not run:
                logger.error(f"Run not found: {run_id}")
                raise HTTPException(status_code=404, detail="Run not found")
            if run.thread_id != thread_id:
                logger.error(f"Run {run_id} does not belong to thread {thread_id}")
                raise HTTPException(status_code=400, detail="Run-thread mismatch")

        # Persist the delta
        delta_obj = Delta(
            content=delta.content,
            filename=delta.filename if hasattr(delta, "filename") else None,
            step_details=delta.step_details if hasattr(delta, "step_details") else None,
            run_id=run_id,
            thread_id=thread_id,
            message_id=message_id,
        )
        session.add(delta_obj)
        session.commit()
        logger.info(f"Created delta {delta_obj.id} for message {message_id}")

        # If the message's run is being streamed, queue the delta
        if message.run_id and message.run_id in run_queues:
            delta_event = delta_obj.to_openai().model_dump_json()  # Convert to OpenAI-compatible JSON
            await run_queues[message.run_id].put(delta_event)
            logger.debug(f"Queued delta {delta_obj.id} for run {message.run_id}")


@streaming_router.get("/threads/{thread_id}/subscribe")
async def thread_subscribe(
    thread_id: str,
    message_id: Optional[str] = None,
    auth: AuthToken = Depends(revokable_auth),
):
    """Subscribe to deltas for a thread (for testing or future use, primary streaming is handled via runs)."""
    with get_session() as session:
        thread = session.get(Thread, thread_id)
        if not thread:
            raise HTTPException(status_code=404, detail="Thread not found")

        _check_thread_permissions(auth, session, thread_id)

        # Query for deltas
        query = select(Delta).where(Delta.thread_id == thread_id)

        # If message_id is provided, filter by message_id as well
        if message_id:
            query = query.where(Delta.message_id == message_id)

        # Order by creation time
        query = query.order_by(Delta.created_at)

        # Execute the query
        deltas = session.exec(query).all()

        # Stream the deltas
        async def stream_deltas():
            for delta in deltas:
                delta_event = delta.to_openai().model_dump_json()
                yield f"data: {delta_event}\n\n"

            # End the stream
            yield 'data: {"message": "End of stream"}\n\n'

        return StreamingResponse(stream_deltas(), media_type="text/event-stream")
